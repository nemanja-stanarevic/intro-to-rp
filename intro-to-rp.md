An Introduction to Reactive Programming=======================================##To Callback Hell and BackThere has been a significant shift in recent years towards server-side andnetwork programming using event-driven asynchronous runtime environments andframeworks such as Node.js, Twisted, and Netty/NIO.  However, with event-drivenasynchronous programming, what typically starts as straightforward synchronouscode often leads to a mess of nested callbacks.Consider the following example of single-threaded synchronous code:`countWordOccurrences` function takes a `List` of URLs and a keyword, fetchesHTML behind each URL, parses HTML into DOM representation, and counts the numberof times the keyword occurs within each page.  It returns a `List` of pairs ofURL and the count:```scala/* code block 1 - synchronous flow */```This code is easy to reason about - operations are performed one after another,in the specified order.  However, this is not very efficient - each URL lookupis independent from another and thus easily parallelized, yet this code executesthem serially.  Furthermore, each operation involves network IO and will blockthe execution thread while waiting for IO to complete.With event-driven asynchronous approach, the code would look something like this:```scala/* code block 2 – nested event handlers */```Here, each function returns immediately and execution continues while network IOis underway.  A callback function passed as an argument is executed once thenetwork IO is completed.  This allows for more efficient use of system resources,but necessitates a shared mutable state resulting in the code that is harder toread and understand.  Specifically, each asynchronous processing step we addrequires a nested callback, quickly leading to what is commonly referred to as"callback hell".Can we do better? Can we combine the simplicity and readability of the synchronousapproach with the efficiency of the asynchronous code? It turns out we can.`Future` allows us to encapsulate and abstract event-handling code and usehigher-order functions, such as map, reduce, and filter, to compose clean,readable, asynchronous code.While these examples are in Scala, the abstractions and patterns described areapplicable to most modern languages.  Basic familiarity with functional patternsis assumed but you can catch up reading [Mary’s awesome introduction to functionalprogramming](https://codewords.hackerschool.com/issues/one/an-introduction-to-functional-programming).##Futures and PromisesWhat is particularly nice about the synchronous code in the first example is thata function like `fetchUrl` returns a `String` value that other functions inturn use for their computations.  This leads to easily readable and composablecode.`Future` and `Promise` traits from `scala.concurrent` package can be used tocreate a new asynchronous version of `fetchUrl` that returns a value instead ofinvoking callbacks. The value returned in this case will be of the type`Future[String]`, signifying that a `String` value will be available at somepoint in the future.The asynchronous version of `fetchUrl` wraps `fetchUrlAsync` used in the secondexample so that we don’t have to deal with callbacks directly.  This type ofwrapping is a very common pattern in reactive programming:```scala/* code block 3 – Future wrapper for `fetchUrlAsync`  using Future/Promise */````Promise` contains a `Future` that is notified when `Promise` is completed forthe first time either with success or failure.  In a way, `Promise` is a "helper"trait that allows for elegant wrapping of callback-based code into `Future`.In this example, function calls `fetchUrlAsync` with a success callback thatcompletes `Promise` `p` with success and a failure callback that completes `p`with failure.  The function then extracts the future out of `p` and returns itto the caller.`parseHtmlToDOM` and `countWordOccurrencesInDOM` would be similarly refactoredto return `Future[DOM]` and `Future[Int]` respectively.##Composing Futures and a Way to Map/Filter/Reduce Hell`Future` trait defines standard higher-order functions such as map, filter, foldand reduce, so it is possible to compose functions returning `Future` usingfunctional programming patterns as follows:```scala/* code block 4 – beautiful functional reactive version of the code */```The new version of the function simply `map`s the list of URLs over `fetchUrl`function returning a `Future`, then `flatMap`s over `parseHtmlToDOM` and`countWordOccurrencesInDOM` to get the count for each URL.While this code appears cleaner than the callback example, it is easy to imaginehow quickly it can become complicated with added processing steps.  It feels likewe are simply trading callback hell for map/filter/reduce hell.Also, reactive code composed with higher-order functions is often not purelyfunctional – it typically involves side effects through network or file system IO.Is there an even better way to write asynchronous code?##Macros to the Rescue: Async/Await[Scala Async](https://github.com/scala/async) library provides `async` and `await`macros inspired by the similar constructs originally introduced by C#. Themacros make it possible to write efficient asynchronous code in direct style,very similar to how synchronous code is written in the first example.Basic approach is to wrap each block of asynchronous code within an `async` blockand each computation resulting in a `Future` within an `await` block.  Thecomputation within `await` block will be "suspended" until the corresponding`Future` is completed, but in a non-blocking fashion and without any performancepenalties.  ```scala/* code block 5 – even more beautiful direct code using async/await */```The code above reflects programmer’s intent more directly and feels more natural.##What’s Next?There are a few more reactive patterns that are particularly useful: `Observable`and `Actor`.Similarly to how `Future` provides a nice abstraction over discrete events,`Observable` provides a powerful abstraction over event streams.`Actor` on the other hand provides powerful building blocks for message passingapplications, such as messaging servers, trading systems and telecom appliances.