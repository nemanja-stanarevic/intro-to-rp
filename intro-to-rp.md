An Introduction to Reactive Programming=======================================##To Callback Hell and BackThere has been a significant shift in recent years towards server-side andnetwork programming using event-driven asynchronous runtime environments andframeworks such as Node.js, Twisted, and Netty/NIO.  However, with event-drivenasynchronous programming, what typically starts as straightforward synchronouscode often leads to a mess of nested callbacks.Consider the following example of single-threaded synchronous code:`countWordOccurrences` function takes a `List` of URLs and a keyword, fetchesHTML behind each URL, parses HTML into DOM representation, and counts the numberof times the keyword occurs within each page.  It returns a `List` of pairs ofURL and the count:```scala  def countWordOccurrences(urls: List[String], keyword: String): List[(String, Int)] = {    urls map { url =>      val html = fetchUrl(url)      val dom = parseHtmlToDOM(html)      val numberOfOccurences = countWordOccurrencesInDOM(dom, keyword)      (url, numberOfOccurences)    }  }```This code is easy to reason about - operations are performed one after another,in the specified order.  However, this is not very efficient - each `fetchUrl`call is independent from another and thus easily parallelized, yet this code executes them serially.  Furthermore, each `fetchUrl` operation involves network IO and will block the execution thread while waiting for IO to complete.With event-driven asynchronous approach, the code may look something like this:```scala  def countWordOccurrencesAsync(      urls: List[String],       keyword: String,      successHandler: (List[(String, Int)]) => Unit,      errorHandler: (Throwable) => Unit): Unit = {    // access to these shared variables would need     // to be synchronized, adding even more complexity    var resultsAccumulator = List[(String, Int)]()    var isUrlCompleted = urls      .foldLeft(HashMap[String, Boolean]()) {        (acc, url) =>          acc.updated(url, false)      }    urls map { url =>      fetchUrlAsync(        url,         successHandler = { html =>          parseHtmlToDOMAsync(            html,            successHandler = { dom =>              countWordOccurrencesInDOMAsync(                dom,                keyword,                 successHandler = { count =>                  // add this result to the resultsAccumulator                  resultsAccumulator = (url, count) :: resultsAccumulator                  // update state to denote that this url is completed                  isUrlCompleted = isUrlCompleted.updated(url, true)                  // check if all urls have been completed                  // if so, invoke the top success handler                  val allDone = isUrlCompleted                                  .map { case(key, value) => value }                                  .reduce { (a, b) => a && b }                  if (allDone) {                    successHandler(resultsAccumulator)                  }                },                errorHandler)            },            errorHandler)        },        errorHandler)    }  }```Here, each `...Async` function returns immediately and execution continues whilenetwork IO or other computation is underway.  Callback functions are passed asarguments to handle cases when operation is successful and when error occurs.The callbacks are executed once the operation is completed.This approach allows for more efficient use of system resources, but still has a number of drawbacks: - Need for shared state variables (`resultsAccumulator` and `isUrlCompleted`)   and synchronization of access - Each asynchronous processing step requires a nested callback, quickly leading    to "callback hell" - Code is much harder to read and understandCan we do better? Can we combine the simplicity and readability of the synchronousapproach with the efficiency of the asynchronous code? It turns out we can.`Future` allows us to encapsulate and abstract event-handling code and usehigher-order functions, such as map, reduce, and filter, to compose clean,readable, asynchronous code.While these examples are in Scala, the abstractions and patterns described areapplicable to most modern languages.  Basic familiarity with functional patternsis assumed but you can catch up reading [Mary’s awesome introduction to functionalprogramming](https://codewords.hackerschool.com/issues/one/an-introduction-to-functional-programming).##Futures and PromisesWhat is particularly nice about the synchronous code in the first example is thata function like `fetchUrl` returns a `String` value that other functions inturn use for their computations.  This leads to easily readable and composablecode.`Future` and `Promise` traits from `scala.concurrent` package can be used tocreate a new asynchronous version of `fetchUrl` that returns a value instead ofinvoking callbacks. The value returned in this case will be of the type`Future[String]`, signifying that a `String` value will be available at somepoint in the future.The asynchronous version of `fetchUrl` wraps `fetchUrlAsync` used in the secondexample so that we don’t have to deal with callbacks directly.  This type ofwrapping is a very common pattern in reactive programming:```scala  def fetchUrl(url: String) : Future[String] = {    val p = Promise[String]()    fetchUrlAsync(url,       successHandler = { html => p.success(html) },       errorHandler = { error => p.failure(error) })    p.future  }````Promise` contains a `Future` that is notified when `Promise` is completed forthe first time either with success or failure.  In a way, `Promise` is a "helper"trait that allows for elegant wrapping of callback-based code into `Future`.In this example, function `fetchUrl` calls `fetchUrlAsync` with a success callback thatcompletes `Promise` `p` with success and a failure callback that completes `p`with failure.  The function then extracts a `Future` out of `p` and returns itto the caller.`parseHtmlToDOM` and `countWordOccurrencesInDOM` would be similarly refactoredto return `Future[DOM]` and `Future[Int]` respectively.##Composing Futures and a Way to Map/Filter/Reduce Hell`Future` trait defines standard higher-order functions such as map, filter, foldand reduce, so it is possible to compose functions returning `Future` usingfunctional programming patterns as follows:```scala  def countWordOccurrences(urls: List[String], keyword: String):    Future[List[(String, Int)]] = {    // partially apply countWordOccurrencesInDOM    val countKeywordOccurencesInDOM = countWordOccurrencesInDOM(_: DOM, keyword)    // expression evaluates to List[Future[(String, Int)]    val listOfFutures = urls      .map { url =>              fetchUrl(url)               .flatMap(parseHtmlToDOM)               .flatMap(countKeywordOccurencesInDOM)               .map { count => (url, count) } }    // transform List[Future[(String, Int)] to Future[List[(String, Int)]]    Future.sequence(listOfFutures)  }```The new version of the function simply `flatMap`s the result of `fetchUrl`function (`Future[String]`) over `parseHtmlToDOM` (returning Future[DOM]) and`countKeywordOccurencesInDOM` (returning Future[Int]) and finally maps the resultto a pair of URL and count, resulting in Future[(String, Int)].The last step is necessary to transform a list of `Furture`s to a `Future` oflist.While this code appears cleaner than the callback example, it is easy to imaginehow quickly it can become complicated with added processing steps.  It feels likewe are simply trading callback hell for map/filter/reduce hell.Also, reactive code composed with higher-order functions is often not purelyfunctional – it typically involves side effects through network or file system IO.Is there an even better way to write asynchronous code?##Macros to the Rescue: Async/Await[Scala Async](https://github.com/scala/async) library provides `async` and `await`macros inspired by the similar constructs originally introduced by C#. Themacros make it possible to write efficient asynchronous code in direct style,very similar to how synchronous code is written in the first example.Basic approach is to wrap each block of asynchronous code within an `async` blockand each computation resulting in a `Future` within an `await` block.  Thecomputation within `await` block will be "suspended" until the corresponding`Future` is completed, but in a non-blocking fashion and without any performancepenalties.  ```scala  def countWordOccurrences(urls: List[String], keyword: String):    Future[List[(String, Int)]] = {    // listOfFutures evaluates to type List[Future[(String, Int)]    val listOfFutures = urls      .map { url => async {        // html, dom and numberOfOccurences values are of type String,         // DOM, and Int respectively        val html = await { fetchUrl(url) }        val dom = await { parseHtmlToDOM(html) }        val numberOfOccurences = await { countWordOccurrencesInDOM(dom, keyword) }        (url, numberOfOccurences)       }    }    // transform List[Future[(String, Int)] to Future[List[(String, Int)]]    Future.sequence(listOfFutures)  }```The code above looks nearly identical to the synchronous code from thefirst example, reflects programmer's intent more directly, and feels more natural.##What’s Next?We barely scratched the surface of reactive programming using `Future`, `Promise` and`async`/`await` constructs.  In addition to these, there are a few more reactivepatterns that are particularly useful: `Observable` and `Actor`.`Observable` provides a powerful abstraction over event streams, similarly tohow `Future` provides an abstraction over discrete events. `Actor` on the other hand provides building blocks for distributed, fault-tolerant message passing applications, such as  messaging servers, trading systems and telecom appliances.